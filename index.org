# Seed for org-mode + reveal.js (4.x) presentation using org-re-reveal
# Use C-c C-e v v to export

# Org-mode Customizations
# Enable in-buffer virtual slide numbering, show headings, hide code blocks
#+STARTUP: num content hideblocks
#+OPTIONS: toc:nil d:nil timestamp:nil num:t email:t ':t
#  Disable exporting of TOC, drawer, creation time stamp
#  Enable auto-numbering headings, smart quotes and exporting of email
#    Auto-numbering is needed to give slides sequential URIs (see below)

# Reveal Customizations
#+REVEAL_VERSION: 4
#+REVEAL_THEME: night
#+REVEAL_TRANS: slide
#+REVEAL_SPEED: fast
# Enable syntax highlighting, zoom (M-click), search (C-S-f), speaker notes
#+REVEAL_PLUGINS: (highlight zoom notes search)
#+REVEAL_HIGHLIGHT_CSS: ./reveal.js/plugin/highlight/monokai.css
#+REVEAL_EXTRA_CSS: ./styles.css

#+name: startup
#+begin_src emacs-lisp :exports none :results none
  (if (not (require 'org-re-reveal nil t))
    (warn "Failed loading ox-reveal package")
    (set (make-local-variable 'org-re-reveal-width) 1920)
    (set (make-local-variable 'org-re-reveal-height) 1080)
    ;; give slides sequential URIs; refer org-re-reveal-generate-custom-ids
    (set (make-local-variable 'org-re-reveal-history) t))
#+END_SRC

#+title: Build Fundamentals
#+author: Sundaram Ramaswamy
#+email: sundaram@microsoft.com

* Agenda

#+begin_notes
Levels of automation, really.
#+end_notes

#+ATTR_REVEAL: :frag (appear)
1. Manual: *Hand-made*
   - Binaries
   - Build Configurations
2. Build system: */Make/*, /Ninja/, /MSBuild/, ...
   - Targets
   - Recipes
   - Dependencies
3. Meta-build system: */GN/*, /CMake/, /meson/, ...

* Part 1 -- /Manual/
* Hand-+Make+ Made

#+begin_src bash
  # GCC/Clang on Linux/macOS
  $ g++ hello.cpp
  $ ./a.out
  $ g++ -std=c++20 -Wall hello.cpp -o hello
  $ ./hello
  
  # MSVC on Windows
  > cl /EHsc /std:c++17 /W3 hello.cpp
  > hello.exe
#+end_src

#+ATTR_REVEAL: :frag (none appear)
- Common Flags
  + Input: /bunch of files/
  + Output: ~-o~
  + Language standard: ~-std=c++14~ _optional_
  + Warning level: ~-Wall~ _best practise_ _optional_
- ~g++~ and ~cl~ are just +compiler+ toolchain front-ends
  + Clang (~clang++~) copies GCC‚Äôs flags

\\

#+ATTR_REVEAL: :frag appear :frag_index 2
#+begin_quote
A useful +wizardry+ skill even today.
#+end_quote

* Tools in the Chain

#+begin_src cpp
  #include <iostream>                  // preprocessor
  
  float perimeter(float radius);       // compiler
  extern float PI;                     // linker
  
  int main() {                         // linker
    constexpr auto radius = 2.71828f;  // compiler
    std::cout << perimeter(radius);    // compiler + linker
  }
#+end_src

- Many tools come together in making a /binary/
  + Preprocessor: glorified find-replace / copy-paste
  + Compiler: generates code
  + Linker: resolves dependencies
  + /more.../
- Front-end \rightarrow /arguments/ \rightarrow Back-end
  + Directly or Indirectly

\\

| Add        | Include Dir (Preprocessor) | Library Dir (Linker) |
|------------+----------------------------+----------------------|
| Directly   | ~-I./inc~                  | ~-L./libs~           |
| Indirectly | ~-Xpreprocessor -I./inc~   | ~-Xlinker -L./libs~  |

* Binaries

- Build lingo: /artefacts/
- Kinds
  1. Executable
  2. Static Library
  3. Shared Library

\\

| Kind       | Definition                     | Load | Link |
|------------+--------------------------------+------+------+
| Executable | Process starting point         | ‚úì    |      |
| Library    | Collection of useful code/data |      | ‚úì    |

* Object/Machine Code

#+ATTR_REVEAL: :frag appear :frag_idx 5
#+begin_src bash
  $ g++ -std=c++17 -c hello.cpp
  $ ls
  hello.cpp    hello.o
  $ nm hello.o
  0000000000000000 T greet
  
  > cl /EHsc /c hello.cpp
  > dir
  hello.cpp    hello.obj
  > dumpbin /symbols hello.obj
#+end_src

#+ATTR_REVEAL: :frag (appear) :frag_idx (1 3 4)
- C++ \rightarrow +byte+ *native code*; runs on actual CPU
  #+ATTR_REVEAL: :frag (appear) :frag_idx (2)
  + Not interpreted by VM¬π
    - Java: /JVM/, Python: /CPython/, C#: /CLR/, ...
- Non-portable binary; depends on
  + Architecture (arm64, x64, MIPS, PowerPC, ...) _EXECUTE_
  + OS (Linux, Windows, macOS, ...) _LOAD_ _SYSCALLS_
- Basic unit of /compiled/ C, C++ and Obj-C
  + GCC/Clang: ~.o~
  + MSVC: ~.obj~

#+ATTR_REVEAL: :frag appear :frag_idx 2
#+ATTR_HTML: :class footnote
1: Don‚Äôt conflate with entire machine VMs like /Hyper-V/, /VirtualBox/, ...

* Executable

#+begin_src bash
  # How do I find the OS/architecture of some rogue binary?

  # Linux
  $ file my_bin
  my_bin: ELF 64-bit, x86-64, GNU/Linux 3.2.0, stripped
  
  # macOS
  $ file my_bin
  my_bin: Mach-O 64-bit executable x86_64
  
  # Windows (MSYS2 or WSL2)
  > file my_bin.exe
  my_bin.exe: PE32+ executable (console) x86-64, for MS Windows
#+end_src

#+ATTR_REVEAL: :frag (none appear)
- Linker expects entry point
  + C-family standard: ~int main()~
  + OS alternatives e.g. ~WinMain~
- *Static dependencies resolved early* _build_
- *Dynamic dependencies resolved late* _run_
- Dependency Components
  + Headers (~.h~) _compiler_ _toolchain_
  + Libraries (~.a~, ~.so~, ~.lib~, ~.dll~, ...) _linker_ _os_
- Common Dependencies
  + System & third-party e.g. [[http://www.libpng.org/pub/png/libpng.html][libpng]] (~png.h~ + ~libpng.a~)

\\

| OS Family | Extension | Format                             |
|-----------+-----------+------------------------------------|
| Unix      | /none/    | Executable & Linkable Format ([[https://en.wikipedia.org/wiki/Executable_and_Linkable_Format][ELF]]) |
| Windows   | ~.exe~    | Portable Executable ([[https://en.wikipedia.org/wiki/Portable_Executable][PE/PE32+]])     |
| macOS     | /none/    | Mach object ([[https://en.wikipedia.org/wiki/Mach-O][Mach-O]])               |

* Static vs Shared Libraries

#+begin_example
 +---------------------+----------+      +--------------+   +--------------+
 |                     |          |      |              |   |              |
 |                     |          |      |              |   |              |
 |   Application 1     |  Static  |      | Application  |   | Application  |
 |                     |  Lib A   |      |      3       |   |      4       |
 |                     |          |      |              |   |              |
 +---------------------+----------+      +------\-------+   +------/-------+
                                                 \                /
                                                  \              /
 +---------------------+----------+           +----\------------/-----+
 |                     |          |           |                       |
 |                     |          |           |                       |
 |   Application 2     |  Static  |           |    Shared Library B   |
 |                     |  Lib A   |           |                       |
 |                     |          |           |                       |
 +---------------------+----------+           +-----------------------+

#+end_example

* Static Library

#+ATTR_REVEAL: :code_attribs data-line-numbers='1,2,4,13-15'
#+begin_src bash
  $ ar -rcs libTrig.a sin.o cos.o tan.o
  $ ar -t libTrig.a
  sin.o cos.o tan.o
  $ nm libTrig.a
  0000000000000000 T sin
  0000000000001000 T cos
  
  $ ls -l
  80K   libTrig.a
  20K   libmath.a
  200K  tool.o
  $ gcc -o tool tool.o libTrig.a
  ld: sin.o: undefined reference to 'add(int, int)'
  $ gcc -o tool tool.o -ltrig -lmath
  $ ls -l tool
  300K  tool
#+end_src

#+begin_src bash :exports none
  > lib /out:trig.lib sin.obj cos.obj tan.obj
  > lib /list trig.lib
  sin.obj cos.obj
#+end_src

#+ATTR_REVEAL: :frag (appear)
- An archive of object files _linker_
  + With interface headers e.g. ~trig.h~ _compiler_
- *Code attached to final executable* _build_
  + Static/Compile-time linking by linker
- *Dependencies aren‚Äôt resolved!* _build_
  + Final binary to supply dependency
- Toolchain feature; OS uninvolved
- No entry functions ~main()~, ~DllMain()~, ...

** Pros & Cons

| No ‚Äúmissing dependencies‚Äù error for app    | No sweeping updates / fixes                 |
| No version mismatches or [[https://en.wikipedia.org/wiki/Dependency_hell][Dependency Hell]]   | Every app to rebuild on update              |
| Single executable; simpler package/install | Disk space (fat binaries, multiple copies)¬π |
| Apps may ignore breaking lib version       | No on-demand loading / plug-ins             |
| Library needn‚Äôt be backward-compatible     | Slower build time for app (strip unused)    |

#+ATTR_HTML: :style font-size: large;
1: Doesn‚Äôt apply to /Windows/; each software brings its own (non-system) libraries

* Shared/Dynamic Library

#+ATTR_REVEAL: :code_attribs data-line-numbers='1,6,12'
#+begin_src bash
  $ g++ -o tool tool.o
  $ ls -l
  200K  tool.o
  200K  tool
  
  $ g++ -shared -fPIC {sin,cos,tan}.cpp -o trig.dll -lmath
  $ nm trig.dll
  0000000000000000 T sin
  0000000000001000 T cos ...
  
  $ gcc -o tool tool.o trig.dll
  $ ls -l
  80K   trig.dll
  200K  tool.o
  200K  tool
#+end_src

#+ATTR_REVEAL: :frag (appear)
- Single library shared across apps _run_
  + Single copy in memory at runtime
- *Static dependencies resolved* _build_
  + Need dynamic dependencies at launch
  + ~a.dll~ \rightarrow ~b.dll~ \rightarrow ... üò≤ _dependency chain_
- *Final executable contains +code+ only jumps*
- Dynamic/run-time linking by OS/loader _run_
  + Expects library presence in right path on
    - Launch
    - Demand: ~dlopen~, ~LoadLibrary~
- Entry functions e.g. ~DllMain~

\\

| OS      | Name                                                |
|---------+-----------------------------------------------------|
| Windows | Dynamic Link Libraries (~.dll~)                     |
| Linux   | Shared Objects (~.so~)                              |
| macOS   | Dynamic Shared Libraries/Bundles (~.dylib~ / ~.so~) |

** Pros & Cons

| Sweeping updates / fixes               | Missing dependencies; failure to launch       |
| Plug-ins / on-demand loads             | Versioning / Dependency Hell                  |
| Toolchain independent; cross-toolchain | OS dependent                                  |
| No app rebuilding                      | Many OS-specific binaries; pkg/install hassle |
| Lesser disk footprint                  | Backward-compatible considerations            |
|                                        | Forced updates breaking app                   |

* Tools and Switches

#+begin_src bash
  # GCC/MinGW on Windows
  > g++ -std=c++17 -D_DEBUG hello.cpp -g -O0 -flto -o hello.exe
  
  # MSVC on Windows
  > cl /EHsc /std:c++17 /D_DEBUG hello.cpp /Zi /Od /LTCG
#+end_src

#+ATTR_REVEAL: :frag (appear)
- Compiler Flags
  + Enable debug symbols: ~-g~
  + Disable optimizations: ~-O0~
- Linker Flags
  + Link time optimization: ~-flto~
- Preprocessor Flags
  + Define macros, add include dirs, etc.
  + ~-D_DEBUG~ \rightarrow ~#define _DEBUG~
  + ~-DPI=3.14~ \rightarrow ~#define PI 3.14~
- *List of flags can get long, /really long/*
  + MSVC: 166 (/1 platform, arch-neutral/)
  + GCC: [[https://gcc.gnu.org/onlinedocs/gcc-11.1.0/gcc/Option-Summary.html][gazillion]] (/multi-arch, multi-platform/ ü§Ø)

* Software and Features

#+begin_quote
Conditional compilation of certain pieces of code.
#+end_quote

#+begin_src bash
  # 2. Conditional Inclusion
  # BUILD.gn
  if (is_linux || is_chromeos) {
    sources += [
      "base_paths_posix.cc"
    ]
  }
#+end_src

#+begin_src cpp
  // 1. Macro
  // C++
  #if defined(ENABLE_TAB_TOGGLE)
    tab_toggler.init();
  #endif
#+end_src

#+ATTR_REVEAL: :frag (none none appear)
- Features are made of code
- Code can guarded by switches
  1. Macros
  2. Conditional inclusion of files
- *Binary won‚Äôt have omitted feature‚Äôs bits*
  + Unlike /command-line-flag/-enabled features

* Build Configuration

#+begin_quote
*Configuration*: particular combination of all switches¬π.
#+end_quote

#+ATTR_REVEAL: :frag (appear)
- Theoretically ~m √ó n~ switches (/toolchain √ó software/)
  + Strictly speaking ~m x n~ isn‚Äôt possible
- *Switches can be inter-dependant*
  + Example: turning on PDF might need Print support
  + Example: turning on logging for /Debug/ builds
- Manual: tedious and error-prone
  + Hampers reproducibility, productivity and maintenance

\\

|         | Emojis | Speech | Plugins | Logging | Debug | Optimization |
|---------+--------+--------+---------+---------+-------+--------------|
| Config1 | ‚úì      | ‚úì      | ‚úì       |         |       | ‚úì            |
| Config2 |        |        | ‚úì       | ‚úì       | ‚úì     |              |

#+ATTR_HTML: :class footnote
1: Think: ~args.gn~

* Common Configurations

#+begin_src bash
  $ cd ~/edge/src
  $ gn args out/release_x64 --list --short | wc -l
  $ 887
  
  $ wc -l < out/release_x64/args.gn
  $ 11
  $ gn args out/release_x64 --list --short --overrides-only | wc -l
  $ 20
  
  $ gn args out/release_x64 --list=crashpad_dependencies
  crashpad_dependencies
    Current value = "chromium"
      From //.gn:51
    Overridden from the default = "standalone"
      From //third_party/crashpad/crashpad/build/crashpad_buildconfig.gni:19
#+end_src

- /Debug/
  + Disable optimizations
  + Keep symbols
- /Release/
  + Enable optimizations
  + Strip debug symbols
- Debug \minus logging (/DbgNoLog/)
- Release + debug (/RelDbg/)
- Release + size optimization (/RelMinSize/)
- ...

* Part 2 -- Build System
* Make

#+ATTR_REVEAL: :frag (appear)
- First step towards build automation
- Minimal enough to learn important build concepts
- Powerful enough; still used in production code
  + Good for quick workouts personally
- Cross-platform, cross-toolchain POSIX standard _productivity_
  + GCC/Clang: GNU ~make~, BSD ~make~; MSVC: ~nmake~
  + Most IDEs support Makefile-based projects
  + VS 2019+: UNIX makefile project template
- Rebuild only changed parts _speed_ _dry_
  + Avoids hand-compiling tedium and mistakes
  + Enables build reproducibility in a team

* Makefile Rules ü§ò

#+begin_src makefile
# commonly used flags in variable
CXXFLAGS       = -std=c++17 -Wall
LDFLAGS        = -flto

biryani: rice.o spices.o
    g++ $(LDFLAGS) -o biryani rice.o spices.o
    cp biryani ./installer/bin

spices.o: spices.cpp spices.h
    g++ $(CXXFLAGS) -o spices.o -c spices.cpp

rice.o: rice.cpp rice.h utensils.h spices.h
    g++ $(CXXFLAGS) -o rice.o -c rice.cpp

clean:
    rm -rf biryani *.o

doc: doc.html
doc.html: doc.md
    pandoc -o doc.html doc.md

commit:
    git add $(wildcard *.cpp *.h)
    git commit

.PHONY: clean commit
#+end_src

- Add ~Makefile~ at project root with /rules/
- *Target*: final artefact expected
  + Considered outdated if older than a dependency 
- *Dependency*: ingredients needed to make target
- *Recipe*: snippet making target from dependencies
  + Target /outdated/ ¬π? Re-run recipe!
- Golden Rule
  + /Every target‚Äôs recipe should update file naming it./
  + Add exceptions to ~.PHONY~; always outdated
- ~make~: build first target
  + ~make TARGET~: only build ~TARGET~ (and itd depedencies)

#+ATTR_HTML: :class footnote
1: older than a dependency

* Makefile Refinements

#+begin_src makefile
  # commonly used flags in variable
  CXXFLAGS = $(USERFLAGS) -std=c++17 -Wall
  LDFLAGS  = -flto      # LTO ON
  LDLIBS   = -lz -lmath # libMath.a, libZ.a
  
  biryani: rice.o spices.o
      $(CC) $(LDFLAGS) -o $@ $< $(LDLIBS)
      cp biryani ./installer/bin
  
  spices.o: spices.cpp spices.h
  rice.o: rice.cpp rice.h utensils.h spices.h
  
  clean:
      $(RM) biryani *.o
  
  .PHONY: clean
#+end_src

- More power to build engineer
  + Override settings without editing ~Makefile~
  + ~make CC=clang++~: override toolchain to Clang
  + ~USER_FLAGS='-DMY_SHINY_FEATURE=ON -O3' make~
- Special variables for target ~$@~ and dependencies ~$<~
- Make /knows/ how to build ~.o~ from ~.cpp~, ~.c~, etc.
  + Implicit rule: ~.c.o: $(CC) $(CFLAGS) -c $<~
- Make isn‚Äôt language-specific
  + E.g. ~make install~ is just a bunch of copies

* Makefile Builds

#+begin_src makefile
  .POSIX:
  COMPILER_FLAGS = -Wall -Werror -pedantic -pedantic-errors
  CXXFLAGS       = -std=c++17 $(COMPILER_FLAGS)
  
  all: debug release
  
  debug: CXXFLAGS += -g -O0 -D_DEBUG -DDEBUG
  debug: hello
  
  release: CXXFLAGS += -O2 -DNDEBUG
  release: hello
  
  hello: hello.swift MyCMod/adder.o
      swiftc -I . -o $@ $<
  
  MyCMod/adder.o: MyCMod/adder.cpp MyCMod/adder.h
  
  clean:
      $(RM) hello MyCMod/adder.o
  
  .PHONY: all clean
#+end_src

- Separate debug and release targets
- Per-target variable values
- ~make debug~ and ~make release~
- ~make~ to build both
  + Convention: Make an ~all~ target
- Complexity ‚àù Configurations + Dependencies
  + Natural to any build system
  + No on /writes/ ~build.ninja~
  + [[https://ninja-build.org/][Ninja‚Äôs introduction]] calls this out!

\\

#+begin_quote
‚Äú[...] designed to have its input files generated by a higher-level build system.  Ninja build files are human-readable but not especially convenient to write by hand.‚Äù
#+end_quote

* Part 3 -- Meta-Build System
* Motivation

#+ATTR_REVEAL: :frag (appear)
- A /generator/ of build/project files
  + GN can generate for VS, Xcode, Eclipse, QtCreator
  + Alternatives: [[https://cmake.org/][CMake]], [[https://xmake.io/][xmake.io]], [[https://mesonbuild.com/][meson]], [[https://waf.io/][Waf]], [[https://scons.org/][SCons]], [[https://bazel.build/][Bazel]], ...
- Scriptability
  + Run code based on environment/parameters and generate
  + Copy resources, pre-/post-tasks
- Multi-language support; build systems are tied to languages
  + Ant: Java, Make: C family, Cargo: Rust, ...
- Cross-platform, cross-IDE, cross-language solution
- Natural evolution of build systems
- Best of both worlds
  + CLI: Build automation, speed, correctness
  + GUI: Developer-friendly, wider adoption

* GN Basics

#+begin_src perl
  executable("img_view") {
    sources = [
      "window.cpp",
      "filter.cpp",
    ]
  
    cflags = [ "-Wall" ]
    defines = [ "USE_GPU=1" ]
    include_dirs = [ "./inc" ]
  
    dependencies = [
      ":libpng",                     # in-file
      # ‚Äòcore‚Äô under third_party/animator/BUILD.gn
      "//third_party/animator:core"  # qualified
      # ‚Äòmarkdown‚Äô under third_party/markdown/BUILD.gn
      "//third_party/markdown"       # implicit
    ]
  
    if (is_win) {
      sources += [ "d3d11.cpp" ]
      ldflags = [ "/SUBSYSTEM:WINDOWS",
                  "/DELAYLOAD: d3d11.dll" ]
    }
  }
  
  static_library("libpng") {
    sources = [
        "encoder.c",
        "decoder.c",
      ]
  
    public_deps = [
      "//third_party/boost:file_io"
    ]
  }
  
#+end_src

- Concepts we‚Äôve seen earlier
  + Targets, Dependencies, Flags, Options
- 5 target types for 5 binaries
  + ~executable~, ~static_library~, ~shared_library~
  + ~loadable_module~, ~source_set~
- Labels (~//chrome/broswer:views~) for any node in dependency graph
  + Targets
  + Configurations
  + Toolchains

* Public and Transitive Dependencies

#+begin_src perl
  # A can use B and C but not super_secret
  executable("A") {
    deps = [ ":B" ]
  }
  
  shared_library("B") {
    public_deps = [ ":C" ]
    deps = [ ":super_secret" ]
  }
#+end_src

- Dependency chain: ~A~ \rightarrow ~B~ \rightarrow ~C~
  + ~dependencies~: ~B~ can include/use ~C~; ~A~ can‚Äôt
  + ~public_deps~: A can include ~C~ too
- ~B~ should publicly depend on ~C~ if it‚Äôs part of interface ~B~
- Private dependency if it‚Äôs just implementation detail
- ~A~ inherits ~public_configs~ of ~C~ too
- This is *recursive*!
- Shared Libraries
  + Final target links to all publicly dependent shared libraries

:gn_setup_files:
- ~//.gn~: defines project root; see ~gn help dotfile~
- ~//build/config/BUILDCONFIG.gn~: global variables and default settings
:end:

* Configurations
* References

* Thank you

# https://emacs.stackexchange.com/q/12938/4106
# Local Variables:
# org-confirm-babel-evaluate: nil
# eval: (progn (org-babel-goto-named-src-block "startup") (org-babel-execute-src-block) (outline-hide-sublevels 1))
# End:
